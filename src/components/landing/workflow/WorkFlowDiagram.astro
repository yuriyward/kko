---
import WorkFlowDiagramStep, { type Step } from "./WorkFlowDiagramStep.astro";
import ChatIcon from "@assets/icons/chat-icon.svg";
import CheckboxIcon from "@assets/icons/checkbox-icon.svg";
import IdeaIcon from "@assets/icons/idea-icon.svg";
import QuestionIcon from "@assets/icons/question-icon.svg";

const workSteps: Step[] = [
    {
        id: "01",
        title: "Занурення в проблематику",
        description: "Детальна діагностика для розуміння викликів і потреб.",
    },
    {
        id: "02",
        title: "Пошук рішень",
        description:
            "За потреби залучаємо експертів, які допоможуть посилити вирішення вашого запиту. Визначаємо цілі та пріоритети.",
    },
    {
        id: "03",
        title: "Організація процесу / Навчання команди",
        description:
            "Формуємо структуру роботи та підвищуємо компетенції учасників.",
    },
    {
        id: "04",
        title: "Розробка рішень",
        description:
            "Розробка рішень і підходів, які об'єднують команду та мотивують до спільних дій. За індивідуальним запитом підтримуємо реалізацію змін.",
    },
];
---

<div id="diagram-container" class="w-full relative">
    <div class="flex flex-col gap-32 2xl:ml-[10%]">
        <div class="flex flex-col md:flex-row md:gap-[15%] gap-32">
            <WorkFlowDiagramStep step={workSteps[0]}>
                <QuestionIcon slot="icon-slot" />
            </WorkFlowDiagramStep>

            <WorkFlowDiagramStep step={workSteps[2]}>
                <CheckboxIcon slot="icon-slot" />
            </WorkFlowDiagramStep>
        </div>
        <div class="flex flex-col md:flex-row md:gap-[25%] gap-32 md:ml-[15%]">
            <WorkFlowDiagramStep step={workSteps[1]}>
                <IdeaIcon slot="icon-slot" />
            </WorkFlowDiagramStep>
            <WorkFlowDiagramStep step={workSteps[3]}>
                <ChatIcon slot="icon-slot" />
            </WorkFlowDiagramStep>
        </div>
    </div>
    <svg id="connecting-lines" class="absolute inset-0 pointer-events-none"
    ></svg>
</div>

<script>
    interface Point {
        x: number;
        y: number;
    }

    interface Connection {
        from: string;
        to: string;
        padding: number;
        curveFactor: number;
        startOffsetX?: number;
        endOffsetX?: number;
    }

    class DiagramConnector {
        private container: HTMLElement;
        private svg: SVGElement;
        private connections: Connection[];
        private resizeHandler: () => void;
        private resizeTimeout: number | null = null;

        constructor(
            containerId: string,
            svgId: string,
            connections: Connection[]
        ) {
            const container = document.getElementById(containerId);
            const svg = document.getElementById(svgId);

            if (!container || !svg || !(svg instanceof SVGElement)) {
                throw new Error("Required elements not found");
            }

            this.container = container;
            this.svg = svg;
            this.connections = connections;

            // Bind methods
            this.resizeHandler = this.debouncedUpdateLines.bind(this);

            this.init();
        }

        private init(): void {
            try {
                this.updateLines();
                window.addEventListener("resize", this.resizeHandler);
                window.addEventListener("load", this.updateLines.bind(this));
                setTimeout(() => this.updateLines(), 500);
            } catch (error) {
                console.error("Failed to initialize diagram:", error);
            }
        }

        private debouncedUpdateLines(): void {
            if (this.resizeTimeout) {
                window.cancelAnimationFrame(this.resizeTimeout);
            }
            this.resizeTimeout = window.requestAnimationFrame(() => {
                this.updateLines();
                this.resizeTimeout = null;
            });
        }

        public destroy(): void {
            window.removeEventListener("resize", this.resizeHandler);
            if (this.resizeTimeout) {
                window.cancelAnimationFrame(this.resizeTimeout);
            }
        }

        private getEdgePoint(
            rect: DOMRect,
            center: Point,
            targetCenter: Point,
            extraPadding: number
        ): Point {
            const dx = targetCenter.x - center.x;
            const dy = targetCenter.y - center.y;
            const halfWidth = rect.width / 2;
            const halfHeight = rect.height / 2;
            const scaleX = dx !== 0 ? halfWidth / Math.abs(dx) : Infinity;
            const scaleY = dy !== 0 ? halfHeight / Math.abs(dy) : Infinity;
            const scale = Math.min(scaleX, scaleY);

            const edge = {
                x: center.x + dx * scale,
                y: center.y + dy * scale,
            };

            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 0) {
                edge.x -= (dx / distance) * extraPadding;
                edge.y -= (dy / distance) * extraPadding;
            }

            return edge;
        }

        private createPath(
            start: Point,
            end: Point,
            curveFactor: number
        ): SVGPathElement {
            const cp1 = {
                x: start.x,
                y: start.y + (end.y - start.y) * curveFactor,
            };
            const cp2 = {
                x: end.x,
                y: end.y - (end.y - start.y) * curveFactor,
            };

            const path = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
            );
            path.setAttribute(
                "d",
                `M ${start.x} ${start.y} C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${end.x} ${end.y}`
            );
            path.setAttribute("stroke", "black");
            path.setAttribute("stroke-width", "1");
            path.setAttribute("fill", "none");

            return path;
        }

        public updateLines(): void {
            const contRect = this.container.getBoundingClientRect();
            this.svg.setAttribute("width", String(contRect.width));
            this.svg.setAttribute("height", String(contRect.height));
            this.svg.innerHTML = "";

            this.connections.forEach((connection) => {
                const elFrom = document.getElementById(connection.from);
                const elTo = document.getElementById(connection.to);

                if (!elFrom || !elTo) return;

                const rectFrom = elFrom.getBoundingClientRect();
                const rectTo = elTo.getBoundingClientRect();

                const centerFrom: Point = {
                    x: rectFrom.left - contRect.left + rectFrom.width / 2,
                    y: rectFrom.top - contRect.top + rectFrom.height / 2,
                };
                const centerTo: Point = {
                    x: rectTo.left - contRect.left + rectTo.width / 2,
                    y: rectTo.top - contRect.top + rectTo.height / 2,
                };

                let start = this.getEdgePoint(
                    rectFrom,
                    centerFrom,
                    centerTo,
                    connection.padding
                );
                if (connection.startOffsetX) {
                    start.x += connection.startOffsetX;
                }

                let end = this.getEdgePoint(
                    rectTo,
                    centerTo,
                    centerFrom,
                    connection.padding
                );
                if (connection.endOffsetX) {
                    end.x += connection.endOffsetX;
                }

                this.svg.appendChild(
                    this.createPath(start, end, connection.curveFactor)
                );
            });
        }
    }

    // Configuration
    const connections: Connection[] = [
        { from: "01", to: "02", padding: -15, curveFactor: 0.5 },
        {
            from: "02",
            to: "03",
            padding: -24,
            curveFactor: 0.6,
            startOffsetX: -100,
            endOffsetX: -100,
        },
        { from: "03", to: "04", padding: -10, curveFactor: 0.4 },
    ];

    // Initialize the diagram with error handling
    try {
        const diagram = new DiagramConnector(
            "diagram-container",
            "connecting-lines",
            connections
        );

        // Cleanup on page unload
        window.addEventListener("unload", () => diagram.destroy());
    } catch (error) {
        console.error("Failed to create diagram:", error);
    }
</script>
