---
import WorkFlowDiagramStep, { type Step } from "./WorkFlowDiagramStep.astro";
import ChatIcon from "@assets/icons/chat-icon.svg";
import CheckboxIcon from "@assets/icons/checkbox-icon.svg";
import IdeaIcon from "@assets/icons/idea-icon.svg";
import QuestionIcon from "@assets/icons/question-icon.svg";

const workSteps: Step[] = [
    {
        id: "01",
        title: "Занурення в проблематику",
        description: "Детальна діагностика для розуміння викликів і потреб.",
    },
    {
        id: "02",
        title: "Пошук рішень",
        description:
            "За потреби залучаємо експертів, які допоможуть посилити вирішення вашого запиту. Визначаємо цілі та пріоритети.",
    },
    {
        id: "03",
        title: "Організація процесу / Навчання команди",
        description:
            "Формуємо структуру роботи та підвищуємо компетенції учасників.",
    },
    {
        id: "04",
        title: "Розробка рішень",
        description:
            "Розробка рішень і підходів, які об'єднують команду та мотивують до спільних дій. За індивідуальним запитом підтримуємо реалізацію змін.",
    },
];
---

<div id="diagram-container" class="w-full relative px-4 md:px-0">
    <div class="flex flex-col space-y-16 md:space-y-20 2xl:ml-[10%]">
        <!-- First row -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 md:gap-16">
            <div class="md:pr-8">
                <WorkFlowDiagramStep step={workSteps[0]} class="w-fit">
                    <QuestionIcon slot="icon-slot" />
                </WorkFlowDiagramStep>
            </div>
            <div class="hidden md:block"></div>
        </div>

        <!-- Second row -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 md:gap-16">
            <div class="hidden md:block"></div>
            <div class="md:pl-8">
                <WorkFlowDiagramStep step={workSteps[1]} class="w-fit">
                    <IdeaIcon slot="icon-slot" />
                </WorkFlowDiagramStep>
            </div>
        </div>

        <!-- Third row -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 md:gap-16">
            <div class="md:pr-8">
                <WorkFlowDiagramStep step={workSteps[2]}>
                    <CheckboxIcon slot="icon-slot" />
                </WorkFlowDiagramStep>
            </div>
            <div class="hidden md:block"></div>
        </div>

        <!-- Fourth row -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 md:gap-16">
            <div class="hidden md:block"></div>
            <div class="md:pl-8">
                <WorkFlowDiagramStep step={workSteps[3]}>
                    <ChatIcon slot="icon-slot" />
                </WorkFlowDiagramStep>
            </div>
        </div>
    </div>
    <svg id="connecting-lines" class="absolute inset-0 pointer-events-none"
    ></svg>
</div>

<script>
    interface Point {
        x: number;
        y: number;
    }

    enum EdgePosition {
        TOP = "top",
        RIGHT = "right",
        BOTTOM = "bottom",
        LEFT = "left",
    }

    enum LineDirection {
        UP = "up",
        DOWN = "down",
        LEFT = "left",
        RIGHT = "right",
    }

    enum BendDirection {
        UP = "up",
        DOWN = "down",
        LEFT = "left",
        RIGHT = "right",
    }

    interface Connection {
        from: string;
        to: string;
        startPadding: number;
        endPadding: number;
        bendDirection: BendDirection;
        bendStrength: number; // Controls how much the curve bends (0-1)
        startEdge: EdgePosition;
        endEdge: EdgePosition;
        startDirection: LineDirection;
        endDirection: LineDirection;
        startOffsetX?: number;
        endOffsetX?: number;
    }

    class DiagramConnector {
        private container: HTMLElement;
        private svg: SVGElement;
        private connections: Connection[];
        private resizeHandler: () => void;
        private resizeTimeout: number | null = null;

        constructor(
            containerId: string,
            svgId: string,
            connections: Connection[]
        ) {
            const container = document.getElementById(containerId);
            const svg = document.getElementById(svgId);

            if (!container || !svg || !(svg instanceof SVGElement)) {
                throw new Error("Required elements not found");
            }

            this.container = container;
            this.svg = svg;
            this.connections = connections;

            // Bind methods
            this.resizeHandler = this.debouncedUpdateLines.bind(this);

            this.init();
        }

        private init(): void {
            try {
                this.updateLines();
                window.addEventListener("resize", this.resizeHandler);
                window.addEventListener("load", this.updateLines.bind(this));
                setTimeout(() => this.updateLines(), 500);
            } catch (error) {
                console.error("Failed to initialize diagram:", error);
            }
        }

        private debouncedUpdateLines(): void {
            if (this.resizeTimeout) {
                window.cancelAnimationFrame(this.resizeTimeout);
            }
            this.resizeTimeout = window.requestAnimationFrame(() => {
                this.updateLines();
                this.resizeTimeout = null;
            });
        }

        public destroy(): void {
            window.removeEventListener("resize", this.resizeHandler);
            if (this.resizeTimeout) {
                window.cancelAnimationFrame(this.resizeTimeout);
            }
        }

        private getEdgePoint(
            rect: DOMRect,
            edge: EdgePosition,
            padding: number,
            offsetX: number = 0
        ): Point {
            const point: Point = { x: 0, y: 0 };

            switch (edge) {
                case EdgePosition.TOP:
                    point.x = rect.left + rect.width / 2 + offsetX;
                    point.y = rect.top + padding;
                    break;
                case EdgePosition.RIGHT:
                    point.x = rect.right - padding;
                    point.y = rect.top + rect.height / 2;
                    break;
                case EdgePosition.BOTTOM:
                    point.x = rect.left + rect.width / 2 + offsetX;
                    point.y = rect.bottom - padding;
                    break;
                case EdgePosition.LEFT:
                    point.x = rect.left + padding;
                    point.y = rect.top + rect.height / 2;
                    break;
            }

            return point;
        }

        private adjustControlPoint(
            point: Point,
            direction: LineDirection,
            distance: number
        ): Point {
            const adjusted = { x: point.x, y: point.y };
            switch (direction) {
                case LineDirection.UP:
                    adjusted.y -= distance;
                    break;
                case LineDirection.DOWN:
                    adjusted.y += distance;
                    break;
                case LineDirection.LEFT:
                    adjusted.x -= distance;
                    break;
                case LineDirection.RIGHT:
                    adjusted.x += distance;
                    break;
            }
            return adjusted;
        }

        private createPath(
            start: Point,
            end: Point,
            bendDirection: BendDirection,
            bendStrength: number,
            startDirection: LineDirection,
            endDirection: LineDirection
        ): SVGPathElement {
            const controlDistance = 100; // Base distance for control points
            const midPoint = {
                x: (start.x + end.x) / 2,
                y: (start.y + end.y) / 2,
            };

            // Calculate bend offset based on direction and strength
            const bendOffset = {
                x: (end.x - start.x) * bendStrength,
                y: (end.y - start.y) * bendStrength,
            };

            const cp1 = { ...start };
            const cp2 = { ...end };

            // Apply bend direction
            switch (bendDirection) {
                case BendDirection.UP:
                    cp1.y = midPoint.y - Math.abs(bendOffset.y);
                    cp2.y = midPoint.y - Math.abs(bendOffset.y);
                    break;
                case BendDirection.DOWN:
                    cp1.y = midPoint.y + Math.abs(bendOffset.y);
                    cp2.y = midPoint.y + Math.abs(bendOffset.y);
                    break;
                case BendDirection.LEFT:
                    cp1.x = midPoint.x - Math.abs(bendOffset.x);
                    cp2.x = midPoint.x - Math.abs(bendOffset.x);
                    break;
                case BendDirection.RIGHT:
                    cp1.x = midPoint.x + Math.abs(bendOffset.x);
                    cp2.x = midPoint.x + Math.abs(bendOffset.x);
                    break;
            }

            // Adjust control points based on start/end directions
            const startAdjustment = this.adjustControlPoint(
                start,
                startDirection,
                controlDistance
            );
            const endAdjustment = this.adjustControlPoint(
                end,
                endDirection,
                controlDistance
            );

            cp1.x += (startAdjustment.x - start.x) * 0.5;
            cp1.y += (startAdjustment.y - start.y) * 0.5;
            cp2.x += (endAdjustment.x - end.x) * 0.5;
            cp2.y += (endAdjustment.y - end.y) * 0.5;

            const path = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path"
            );
            path.setAttribute(
                "d",
                `M ${start.x} ${start.y} C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${end.x} ${end.y}`
            );
            path.setAttribute("stroke", "black");
            path.setAttribute("stroke-width", "1");
            path.setAttribute("fill", "none");

            return path;
        }

        public updateLines(): void {
            const contRect = this.container.getBoundingClientRect();
            this.svg.setAttribute("width", String(contRect.width));
            this.svg.setAttribute("height", String(contRect.height));
            this.svg.innerHTML = "";

            this.connections.forEach((connection) => {
                const elFrom = document.getElementById(connection.from);
                const elTo = document.getElementById(connection.to);

                if (!elFrom || !elTo) return;

                const rectFrom = elFrom.getBoundingClientRect();
                const rectTo = elTo.getBoundingClientRect();

                // Adjust points based on container position
                const start = this.getEdgePoint(
                    new DOMRect(
                        rectFrom.left - contRect.left,
                        rectFrom.top - contRect.top,
                        rectFrom.width,
                        rectFrom.height
                    ),
                    connection.startEdge,
                    connection.startPadding,
                    connection.startOffsetX
                );

                const end = this.getEdgePoint(
                    new DOMRect(
                        rectTo.left - contRect.left,
                        rectTo.top - contRect.top,
                        rectTo.width,
                        rectTo.height
                    ),
                    connection.endEdge,
                    connection.endPadding,
                    connection.endOffsetX
                );

                this.svg.appendChild(
                    this.createPath(
                        start,
                        end,
                        connection.bendDirection,
                        connection.bendStrength,
                        connection.startDirection,
                        connection.endDirection
                    )
                );
            });
        }
    }

    // Configuration with separate padding values
    const connections: Connection[] = [
        {
            from: "01",
            to: "02",
            startPadding: -50,
            endPadding: -40,
            bendDirection: BendDirection.UP,
            bendStrength: 0.8,
            startEdge: EdgePosition.RIGHT,
            endEdge: EdgePosition.TOP,
            startDirection: LineDirection.RIGHT,
            endDirection: LineDirection.LEFT,
        },
        {
            from: "02",
            to: "03",
            startPadding: -10,
            endPadding: -20,
            bendDirection: BendDirection.DOWN,
            bendStrength: 0.5,
            startEdge: EdgePosition.LEFT,
            endEdge: EdgePosition.TOP,
            startDirection: LineDirection.DOWN,
            endDirection: LineDirection.UP,
        },
        {
            from: "03",
            to: "04",
            startPadding: 0,
            endPadding: -15,
            bendDirection: BendDirection.RIGHT,
            bendStrength: 0.1,
            startEdge: EdgePosition.RIGHT,
            endEdge: EdgePosition.LEFT,
            startDirection: LineDirection.RIGHT,
            endDirection: LineDirection.LEFT,
        },
    ];

    // Initialize the diagram with error handling
    try {
        const diagram = new DiagramConnector(
            "diagram-container",
            "connecting-lines",
            connections
        );

        // Cleanup on page unload
        window.addEventListener("unload", () => diagram.destroy());
    } catch (error) {
        console.error("Failed to create diagram:", error);
    }
</script>
